\subsection{Impact}
\label{sec:impact}

The main advantage of \parikshan is that it provides an open platform which allows the user to do any kind of debugging/testing on a live clone of the production system which is also receiving the user input.
Natrually, this allows the user to run 
The impact of sandbox testing can be seen in several different ways

\begin{itemize}

  \item \textbf{Monitoring Applications/Localized Errors}
    %The main motivations leading to \emph{Parikshan} is to provide a harness to allow the user to test live applications. 
Most user-end applications have monitoring mechanisms to capture the health of the application built within the system.
Such monitoring mechanisms can often indicate problems in the systems showing spikes or slowdown in CPU usage, memory footprint, cache misses etc.
Very often problems in stable production systems are either (1) restricted to only a small percentage of transactions, (2) are system wide, but have minimal effect on the user (cumulative effect of slow memory leak etc.).
Such problems often do not necessitate taking down the system or lead to a crash
\parikshan can be used to do a live analysis from the point of time when the clone is done, with much deeper monitoring, and light weight testing to localize the errors without worrying about the slowdown to the production system.
%Hence giving an insight into what could have caused the problem, without needing to bring the entire application server down.
%We have tried and tested this in particular for unit-testing cases. 
%While unit-testing cases are undoubtedly self contained, and can be designed like assertions such that they have no after effect on the any subsequent executions, any failure in these test-cases can definetely result in an unclean state.
%Apart from touching the state of the system testing in the production will also lead to a slow-down, which will affect the real system.
%We believe \emph{Parikshan} can be an effective tool to test and analyze unit tests.

  \item \textbf{Fault Tolerance Testing}
    A possible implementation of the \parikshan test harness is to do Fault Tolerance Testing.
As mentioned earlier testing and recreating large-scale configurations is extremely difficult.
Additionally testing scalable aspects is costly as a significantly large test-bed is required to replicate loads. 
Recent large scale fault tolerance testing approaches has been to use fault injection at random places.
One such example is Chaos Monkey\cite{chaosmonkey} which has been employed by Netflix \cite{netflix} video streaming service. 
Netflix has a highly distributed architecture with a large client base, and has several robustness mechanisms inbuilt to manage for failure. 
The chaos monkey infrastructure forces random failiure in live Netflix production servers, to test it's fault tolerance.
The key intuition behind this approach is, that faults in an ever evolving large-scale environment are inevitable, and in most cases the infrastructure will be able to auto-respond and get its instances back to a live state. 
However, in the cases when it is unable to do so, Netflix wants to learn from failures, by forcing them in scheduled low-traffic hours.

Natrually such in production fault-injection mechanisms will always effect the user. 
An alternate mechanism proposed by \parikshan is to use the test-container to inject faults. 
As a clone of the production-container any fault-injected should produce a similar effect as the original container, without effecting the user.

  \item \textbf{Testing Software Updates - AB Testing}
Software patches for performance or functional updates are frequently done on backend servers. 
These may not necessarily change the user-facing input and can be optimizations internal in the back-end server.
Such patches can be first tested in the test-container to verify that they are correctly behaving before doing the release.
A similar approach called A/B Testing\cite{abtesting} is commonly used in mobile and web-applications, which randomly forwards a small percentage of user traffic to a backend server B  a modified version of the backend server(A is the original server). 
This gives the developer a controlled experiment scenario where he can see if the updates work without effecting too many users.
\parikshan can potentially extend this by testing all user input since it does not effect the user experience at all.

%\item \textbf{Verification}

\end{itemize}
