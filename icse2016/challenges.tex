\section{Limitations and Threats to Validity}
\label{sec:limitation}

The first key potential threat to our system is \textbf{non-determinism}. 
Non-determinism can be caused due to three main reasons (1) system configuration, (2) application input, and (3) ordering in concurrent threads.
Live cloning of the application state ensures that both applications are in the same "system-state" and have the same configuration parameters for itself and all dependencies in it's stack.
Furthermore, in offline debugging it is often difficult to capture all possible inputs, and hence deal with input non-determinism.
\parikshan's network proxy ensures that all inputs received in the production container are also forwarded to the debug-container.
However, concurrency based non-determinism can still lead to different execution paths in the production and debug containers.
While the current prototype version of \parikshan is not currently handling concurrency non-determinism within the system, we believe there are several existing techniques that can be applied to tackle this problem in the context of live debugging. 
Firstly, as long as the bug is statistically significant, it can still be caught by execution tracing mechanisms as shown in several previous approaches~\cite{statistical}.
Furthermore, techniques like deterministic scheduling~\cite{deterministicScheduling}, can also be used to counter concurrency based non-deterministic bugs.
Other techniques such as constraint solvers~\cite{DPOR}, can trace synchronization events in a program trace, and search through all possible execution orderings to trigger the concurrency error.


Another threat to \parikshan is that the error once detected, can be 
\iffalse
%\textbf{Triggering \parikshan:}
%The live cloning process of \parikshan can be triggered in various scenarios. 
%Primarily several SOA applications have monitoring mechanisms, which can be 

\textbf{Non-Determinism: } 
Execution of the same input in different conditions can produce different outputs from an application, this behavior is referred to as non-deterministic execution.
With the exception of dedicated controlled executions in embedded systems etc., most large scale applications and complex systems exhibit non-determinism, which is what makes debugging a challenge.

\textbf{\textit{Input non-determinism}} is non-deterministic behavior caused because of different input received by the application (e.g. requests to the server, user input etc.). 
Obviously, any output in the application and it's execution trace, will depend on the input it receives. 
In offline debugging it is often difficult to capture all possible inputs, and hence deal with input non-determinism.
In order to avoid input non-determinism, \parikshan uses a network proxy to send all inputs received in the production container also to the debug-container. 
Hence both of them behave in almost the same fashion.

\textbf{\textit{Configuration non-determinism}} relates to the state of the container, the application configuration, system/kernel parameters, hardware resources etc.
Once again, this can often effect the logic of the application.
For e.g. max no. of threads is a common configuration parameter in several multi-process server applications, and can effect the performance of the application in high workloads.
\parikshan can deal with most configuration/state non-determinism as it captures the state of the production container at the time of cloning, and creates an exact replica.
This replica should have an identical behavior to the original and should have similar memory consumption, threading behavior etc. 
However, some amount of inconsistency between the debug-container and production container is possible.

\textbf{\textit{Concurrency non-determinism}} is caused by parallel applications which may behave differently in each execution.
Capturing this kind of non-determinism is important to debug bugs such as race-conditions, locks etc.
Unfortunately, the current system design of \parikshan cannot capture concurrency based non-determinism, we hope to revise and include this in future versions.

%Several errors in production systems could be caused because of non-determinism in the production server and may not occur in the debug-container.
%However, there are several causes of non-determinism which can lead to an error: for example input non-determinism, state based non-determinism, and concurrency non-determinism.
%Amongst these \parikshan captures input non-determinism by buffering the input to the production container and also sending it to the debug container.
%Furthermore, container kernel and application state is captured while live cloning. 
%However, the debug and production container may follow different threading schedules. 
%Hence it is possible that the bug cannot be captured in the debug-container. There are several ways to offset concurrency non-determinism, for example by using 

%In this paper we have shown a proof-of-concept design and implementation with several case studies on  how \Parikshan can be applied for real-world debugging.

%\textbf{Concurrency non-determinism}: \parikshan can capture the system state and the user input.
%However, it is still possible that we will miss errors which happen because of specific schedules or caching in the production system.
%\parikshan can still be applied 

%\subsection{Rate Limiting}
%\label{sec:ratelimiting}

%\textbf{Rate Limiting}: As we show in section \ref{sec:evaluation}, at extremely high write I/O's it is possible that the suspend time for cloning is sometimes prohibitively high, and can cause TCP timeouts. 
%The operator can thereby chose to use cloning and sandboxing, at low workload conditions. 
%Alternatively, a simple solution to this problem is to use rate-limiting at the proxy which would allow the I/O consumption in the target container to become lower, thereby reducing the suspend time.
%Rate limiting is a commonly used mechanism in proxies, while it reduces the QoS of the application momentarily, it may be better for fast bug resolution.

%\subsection{Dynamic Proxy Insertion}
%\label{sec:dynamicProxyInsertion}

%\textbf{Dynamic Proxy Insertion}: While cloning does happen live, we do not really need to have the proxy to be inserted dynamically as well. 
%Proxies are commonly used in several applications so they can be essentially all the time. 
%However, based on design choice, the proxy can be inserted by starting it up on any server, and then putting a flow redirection rule in the router using dynamic network programming mechanism such as OpenFlow\cite{openflow}.
%Router flows are updated dynamically, and are \texttt{flow-based}, hence can be redirected on the fly using an openflow\cite{openflow} controller.

%\subsection{Slowdown}
%\label{sec:slowdown}


%\subsection{Consistency Requirements}
%\label{sec:consistency}
\fi
\section{Discussion}
\label{sec:discussion}

\textbf{Distributed Services:}  
Large scale distributed systems are often comprised of several interacting services such as storage, NTP, backup service, controllers and resource managers.
\parikshan can be used on one or more containers, and can be used to clone more than one communicating service.
Based on the nature of the service, it may be (a). Cloned, (b). Turned off or (c). allowed without any modification.
For example, storage services supporting a ``debug-container'' need to be cloned or turned off(depending on debugging environment) as they would propagate changes from the cloned container to the production containers.
Similarly, services such as NTP service can be allowed, as they are publish\/subscribe systems and the debug container cannot impact it in anyway.
Furthermore, instrumentation inserted in the debug-container, will not necessarily slowdown all services.
For instance, instrumentation in a MySQL query handler, will not slowdown file-sharing or NTP services running in the same container.

\textbf{Consistency Requirements}: Not all debugging may require very high consistency requirements, and not all overflows would mean that the clone is suddenly out of sync.
In such cases the time-window can be arbitrarily long. 
For example in MySQL read transactions, even if there is a transaction failure or an overflow, it will not effect MySQL itself.
Even with an overflow in some write operations, we could get a weakly consistent representation of the production system's execution.


